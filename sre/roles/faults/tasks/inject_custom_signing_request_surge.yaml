---
# Inject fault: signing-request-surge
# Simulates OCP payload release causing surge in signing requests
# Based on ITN-2025-00221 incident

- name: Create namespace for load generator if it doesn't exist
  kubernetes.core.k8s:
    kubeconfig: "{{ faults_cluster.kubeconfig }}"
    resource_definition:
      apiVersion: v1
      kind: Namespace
      metadata:
        name: "{{ spec.target_service.namespace }}-load-test"
    state: present

- name: Create ConfigMap with load generation script
  kubernetes.core.k8s:
    kubeconfig: "{{ faults_cluster.kubeconfig }}"
    resource_definition:
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: signing-surge-script
        namespace: "{{ spec.target_service.namespace }}-load-test"
      data:
        generate-load.sh: |
          #!/bin/bash
          set -e
          
          ENDPOINT="{{ spec.target_service.endpoint }}"
          SERVICE_URL="http://{{ spec.target_service.name }}.{{ spec.target_service.namespace }}.svc.cluster.local"
          BASELINE_RPS={{ spec.load_profile.baseline_rps }}
          SURGE_MULTIPLIER={{ spec.load_profile.surge_multiplier }}
          SURGE_DURATION={{ spec.load_profile.surge_duration }}
          RAMP_UP_TIME={{ spec.load_profile.ramp_up_time }}
          PAYLOAD_SIZE_KB={{ spec.request_pattern.payload_size_kb }}
          METHOD="{{ spec.request_pattern.method }}"
          
          TARGET_RPS=$((BASELINE_RPS * SURGE_MULTIPLIER))
          REQUESTS_PER_ITERATION=$((TARGET_RPS / 10))  # Iterate every 0.1 seconds
          TOTAL_ITERATIONS=$((SURGE_DURATION * 10))
          
          echo "=== Signing Request Surge Load Generator ==="
          echo "Service: ${SERVICE_URL}${ENDPOINT}"
          echo "Baseline RPS: ${BASELINE_RPS}"
          echo "Surge RPS: ${TARGET_RPS} (${SURGE_MULTIPLIER}x)"
          echo "Duration: ${SURGE_DURATION} seconds"
          echo "Ramp-up: ${RAMP_UP_TIME} seconds"
          echo "Payload size: ${PAYLOAD_SIZE_KB} KB"
          echo "==========================================="
          
          # Generate random payload
          PAYLOAD=$(dd if=/dev/urandom bs=1024 count=${PAYLOAD_SIZE_KB} 2>/dev/null | base64)
          
          # Ramp up phase
          echo "Starting ramp-up phase..."
          RAMP_ITERATIONS=$((RAMP_UP_TIME * 10))
          for i in $(seq 1 $RAMP_ITERATIONS); do
            CURRENT_RPS=$((TARGET_RPS * i / RAMP_ITERATIONS / 10))
            for j in $(seq 1 $CURRENT_RPS); do
              curl -X ${METHOD} -H "Content-Type: application/json" \
                   -d "{\"manifest\":\"${PAYLOAD:0:1000}\"}" \
                   -s -o /dev/null -w "%{http_code}\n" \
                   "${SERVICE_URL}${ENDPOINT}" >> /tmp/responses.log 2>&1 &
            done
            sleep 0.1
          done
          
          echo "Ramp-up complete. Starting sustained load..."
          
          # Sustained load phase
          for i in $(seq 1 $TOTAL_ITERATIONS); do
            for j in $(seq 1 $REQUESTS_PER_ITERATION); do
              curl -X ${METHOD} -H "Content-Type: application/json" \
                   -d "{\"manifest\":\"${PAYLOAD:0:1000}\"}" \
                   -s -o /dev/null -w "%{http_code}\n" \
                   "${SERVICE_URL}${ENDPOINT}" >> /tmp/responses.log 2>&1 &
            done
            sleep 0.1
            
            # Progress reporting every 60 seconds
            if [ $((i % 600)) -eq 0 ]; then
              ELAPSED=$((i / 10))
              REMAINING=$((SURGE_DURATION - ELAPSED))
              RESPONSE_COUNT=$(wc -l < /tmp/responses.log 2>/dev/null || echo 0)
              echo "[${ELAPSED}s] Sent ${RESPONSE_COUNT} requests. ${REMAINING}s remaining..."
            fi
          done
          
          echo "Load generation complete!"
          echo "Total requests sent: $(wc -l < /tmp/responses.log)"
          echo "Response code distribution:"
          sort /tmp/responses.log | uniq -c
    state: present

- name: Create Job to generate signing request surge
  kubernetes.core.k8s:
    kubeconfig: "{{ faults_cluster.kubeconfig }}"
    resource_definition:
      apiVersion: batch/v1
      kind: Job
      metadata:
        name: signing-request-surge-{{ ansible_date_time.epoch }}
        namespace: "{{ spec.target_service.namespace }}-load-test"
        labels:
          fault-type: signing-request-surge
          target-service: "{{ spec.target_service.name }}"
      spec:
        parallelism: 10  # 10 concurrent pods generating load
        completions: 10
        backoffLimit: 0
        template:
          metadata:
            labels:
              fault-type: signing-request-surge
          spec:
            restartPolicy: Never
            containers:
              - name: load-generator
                image: curlimages/curl:latest
                command: ["/bin/sh"]
                args:
                  - -c
                  - |
                    apk add --no-cache bash coreutils
                    bash /scripts/generate-load.sh
                volumeMounts:
                  - name: script
                    mountPath: /scripts
                resources:
                  requests:
                    cpu: "100m"
                    memory: "128Mi"
                  limits:
                    cpu: "500m"
                    memory: "256Mi"
            volumes:
              - name: script
                configMap:
                  name: signing-surge-script
                  defaultMode: 0755
    state: present

- name: Store Job name for later cleanup
  ansible.builtin.set_fact:
    faults_signing_surge_job_name: "signing-request-surge-{{ ansible_date_time.epoch }}"
    faults_signing_surge_namespace: "{{ spec.target_service.namespace }}-load-test"

- name: Wait for Job to start
  kubernetes.core.k8s_info:
    api_version: batch/v1
    kind: Job
    kubeconfig: "{{ faults_cluster.kubeconfig }}"
    name: "{{ faults_signing_surge_job_name }}"
    namespace: "{{ faults_signing_surge_namespace }}"
    wait: true
    wait_condition:
      type: Complete
      status: "False"
    wait_timeout: 30
  register: job_info
  ignore_errors: true

- name: Display load generator status
  ansible.builtin.debug:
    msg: "Signing request surge Job '{{ faults_signing_surge_job_name }}' started in namespace '{{ faults_signing_surge_namespace }}'. Generating {{ spec.load_profile.surge_multiplier }}x load surge for {{ spec.load_profile.surge_duration }} seconds."

